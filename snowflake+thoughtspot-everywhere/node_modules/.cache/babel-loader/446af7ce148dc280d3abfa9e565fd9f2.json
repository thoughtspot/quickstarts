{"ast":null,"code":"/**\n * Copyright (c) 2020\n *\n * Common utility functions for ThoughtSpot Visual Embed SDK\n *\n * @summary Utils\n * @author Ayon Ghosh <ayon.ghosh@thoughtspot.com>\n */\n\n/**\n * Construct a runtime filters query string from the given filters.\n * Refer to the following docs for more details on runtime filter syntax:\n * https://cloud-docs.thoughtspot.com/admin/ts-cloud/apply-runtime-filter.html\n * https://cloud-docs.thoughtspot.com/admin/ts-cloud/runtime-filter-operators.html\n * @param runtimeFilters\n */\nexport const getFilterQuery = runtimeFilters => {\n  if (runtimeFilters && runtimeFilters.length) {\n    const filters = runtimeFilters.map((filter, valueIndex) => {\n      const index = valueIndex + 1;\n      const filterExpr = [];\n      filterExpr.push(`col${index}=${filter.columnName}`);\n      filterExpr.push(`op${index}=${filter.operator}`);\n      filterExpr.push(filter.values.map(value => `val${index}=${value}`).join('&'));\n      return filterExpr.join('&');\n    });\n    return `${filters.join('&')}`;\n  }\n\n  return null;\n};\n/**\n * Convert a value to a string representation to be sent as a query\n * parameter to the ThoughtSpot app.\n * @param value Any parameter value\n */\n\nconst serializeParam = value => {\n  // do not serialize primitive types\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    return value;\n  }\n\n  return JSON.stringify(value);\n};\n/**\n * Convert a value to a string:\n * in case of an array, we convert it to CSV.\n * in case of any other type, we directly return the value.\n * @param value\n */\n\n\nconst paramToString = value => Array.isArray(value) ? value.join(',') : value;\n/**\n * Return a query param string composed from the given params object\n * @param queryParams\n */\n\n\nexport const getQueryParamString = function (queryParams) {\n  let shouldSerializeParamValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const qp = [];\n  const params = Object.keys(queryParams);\n  params.forEach(key => {\n    const val = queryParams[key];\n\n    if (val !== undefined) {\n      const serializedValue = shouldSerializeParamValues ? serializeParam(val) : paramToString(val);\n      qp.push(`${key}=${serializedValue}`);\n    }\n  });\n\n  if (qp.length) {\n    return qp.join('&');\n  }\n\n  return null;\n};\n/**\n * Get a string representation of a dimension value in CSS\n * If numeric, it is considered in pixels.\n * @param value\n */\n\nexport const getCssDimension = value => {\n  if (typeof value === 'number') {\n    return `${value}px`;\n  }\n\n  return value;\n};\n/**\n * Append a string to a URL's hash fragment\n * @param url A URL\n * @param stringToAppend The string to append to the URL hash\n */\n\nexport const appendToUrlHash = (url, stringToAppend) => {\n  let outputUrl = url;\n  const encStringToAppend = encodeURIComponent(stringToAppend);\n\n  if (url.indexOf('#') >= 0) {\n    outputUrl = `${outputUrl}${encStringToAppend}`;\n  } else {\n    outputUrl = `${outputUrl}#${encStringToAppend}`;\n  }\n\n  return outputUrl;\n};\nexport const getEncodedQueryParamsString = queryString => {\n  if (!queryString) {\n    return queryString;\n  }\n\n  return btoa(queryString).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n};\nexport const getOffsetTop = element => {\n  const rect = element.getBoundingClientRect();\n  return rect.top + window.scrollY;\n};","map":{"version":3,"sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Copyright (c) 2020\n *\n * Common utility functions for ThoughtSpot Visual Embed SDK\n *\n * @summary Utils\n * @author Ayon Ghosh <ayon.ghosh@thoughtspot.com>\n */\n/**\n * Construct a runtime filters query string from the given filters.\n * Refer to the following docs for more details on runtime filter syntax:\n * https://cloud-docs.thoughtspot.com/admin/ts-cloud/apply-runtime-filter.html\n * https://cloud-docs.thoughtspot.com/admin/ts-cloud/runtime-filter-operators.html\n * @param runtimeFilters\n */\nexport const getFilterQuery = (runtimeFilters) => {\n    if (runtimeFilters && runtimeFilters.length) {\n        const filters = runtimeFilters.map((filter, valueIndex) => {\n            const index = valueIndex + 1;\n            const filterExpr = [];\n            filterExpr.push(`col${index}=${filter.columnName}`);\n            filterExpr.push(`op${index}=${filter.operator}`);\n            filterExpr.push(filter.values.map((value) => `val${index}=${value}`).join('&'));\n            return filterExpr.join('&');\n        });\n        return `${filters.join('&')}`;\n    }\n    return null;\n};\n/**\n * Convert a value to a string representation to be sent as a query\n * parameter to the ThoughtSpot app.\n * @param value Any parameter value\n */\nconst serializeParam = (value) => {\n    // do not serialize primitive types\n    if (typeof value === 'string' ||\n        typeof value === 'number' ||\n        typeof value === 'boolean') {\n        return value;\n    }\n    return JSON.stringify(value);\n};\n/**\n * Convert a value to a string:\n * in case of an array, we convert it to CSV.\n * in case of any other type, we directly return the value.\n * @param value\n */\nconst paramToString = (value) => Array.isArray(value) ? value.join(',') : value;\n/**\n * Return a query param string composed from the given params object\n * @param queryParams\n */\nexport const getQueryParamString = (queryParams, shouldSerializeParamValues = false) => {\n    const qp = [];\n    const params = Object.keys(queryParams);\n    params.forEach((key) => {\n        const val = queryParams[key];\n        if (val !== undefined) {\n            const serializedValue = shouldSerializeParamValues\n                ? serializeParam(val)\n                : paramToString(val);\n            qp.push(`${key}=${serializedValue}`);\n        }\n    });\n    if (qp.length) {\n        return qp.join('&');\n    }\n    return null;\n};\n/**\n * Get a string representation of a dimension value in CSS\n * If numeric, it is considered in pixels.\n * @param value\n */\nexport const getCssDimension = (value) => {\n    if (typeof value === 'number') {\n        return `${value}px`;\n    }\n    return value;\n};\n/**\n * Append a string to a URL's hash fragment\n * @param url A URL\n * @param stringToAppend The string to append to the URL hash\n */\nexport const appendToUrlHash = (url, stringToAppend) => {\n    let outputUrl = url;\n    const encStringToAppend = encodeURIComponent(stringToAppend);\n    if (url.indexOf('#') >= 0) {\n        outputUrl = `${outputUrl}${encStringToAppend}`;\n    }\n    else {\n        outputUrl = `${outputUrl}#${encStringToAppend}`;\n    }\n    return outputUrl;\n};\nexport const getEncodedQueryParamsString = (queryString) => {\n    if (!queryString) {\n        return queryString;\n    }\n    return btoa(queryString)\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=+$/, '');\n};\nexport const getOffsetTop = (element) => {\n    const rect = element.getBoundingClientRect();\n    return rect.top + window.scrollY;\n};\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}