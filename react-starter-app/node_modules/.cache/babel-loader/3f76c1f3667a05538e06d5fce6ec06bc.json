{"ast":null,"code":"import { initMixpanel } from './mixpanel-service';\nimport { AuthType, EmbedEvent } from './types';\nimport { appendToUrlHash } from './utils'; // eslint-disable-next-line import/no-cycle\n\nimport { fetchSessionInfoService, fetchAuthTokenService, fetchAuthService, fetchBasicAuthService } from './utils/authService'; // eslint-disable-next-line import/no-mutable-exports\n\nexport let loggedInStatus = false; // eslint-disable-next-line import/no-mutable-exports\n\nexport let samlAuthWindow = null; // eslint-disable-next-line import/no-mutable-exports\n\nexport let samlCompletionPromise = null; // eslint-disable-next-line import/no-mutable-exports\n\nexport let sessionInfo = null;\nexport const SSO_REDIRECTION_MARKER_GUID = '5e16222e-ef02-43e9-9fbd-24226bf3ce5b';\nexport const EndPoints = {\n  AUTH_VERIFICATION: '/callosum/v1/session/info',\n  SAML_LOGIN_TEMPLATE: targetUrl => `/callosum/v1/saml/login?targetURLPath=${targetUrl}`,\n  OIDC_LOGIN_TEMPLATE: targetUrl => `/callosum/v1/oidc/login?targetURLPath=${targetUrl}`,\n  TOKEN_LOGIN: '/callosum/v1/session/login/token',\n  BASIC_LOGIN: '/callosum/v1/session/login'\n};\n/**\n * Check if we are logged into the ThoughtSpot cluster\n * @param thoughtSpotHost The ThoughtSpot cluster hostname or IP\n */\n\nasync function isLoggedIn(thoughtSpotHost) {\n  const authVerificationUrl = `${thoughtSpotHost}${EndPoints.AUTH_VERIFICATION}`;\n  let response = null;\n\n  try {\n    response = await fetchSessionInfoService(authVerificationUrl);\n  } catch (e) {\n    return false;\n  }\n\n  return response.status === 200;\n}\n/**\n * Return sessionInfo if available else make a loggedIn check to fetch the sessionInfo\n */\n\n\nexport function getSessionInfo() {\n  return sessionInfo;\n}\nexport function initSession(sessionDetails) {\n  sessionInfo = sessionDetails;\n  initMixpanel(sessionInfo);\n}\n/**\n * Check if we are stuck at the SSO redirect URL\n */\n\nfunction isAtSSORedirectUrl() {\n  return window.location.href.indexOf(SSO_REDIRECTION_MARKER_GUID) >= 0;\n}\n/**\n * Remove the SSO redirect URL marker\n */\n\n\nfunction removeSSORedirectUrlMarker() {\n  // Note (sunny): This will leave a # around even if it was not in the URL\n  // to begin with. Trying to remove the hash by changing window.location will reload\n  // the page which we don't want. We'll live with adding an unnecessary hash to the\n  // parent page URL until we find any use case where that creates an issue.\n  window.location.hash = window.location.hash.replace(SSO_REDIRECTION_MARKER_GUID, '');\n}\n/**\n * Perform token based authentication\n * @param embedConfig The embed configuration\n */\n\n\nexport const doTokenAuth = async embedConfig => {\n  const {\n    thoughtSpotHost,\n    username,\n    authEndpoint,\n    getAuthToken\n  } = embedConfig;\n\n  if (!authEndpoint && !getAuthToken) {\n    throw new Error('Either auth endpoint or getAuthToken function must be provided');\n  }\n\n  const loggedIn = await isLoggedIn(thoughtSpotHost);\n\n  if (!loggedIn) {\n    let authToken = null;\n\n    if (getAuthToken) {\n      authToken = await getAuthToken();\n    } else {\n      const response = await fetchAuthTokenService(authEndpoint);\n      authToken = response.text();\n    }\n\n    await fetchAuthService(thoughtSpotHost, username, authToken);\n    loggedInStatus = false;\n  }\n\n  loggedInStatus = true;\n};\n/**\n * Perform basic authentication to the ThoughtSpot cluster using the cluster\n * credentials.\n *\n * Warning: This feature is primarily intended for developer testing. It is\n * strongly advised not to use this authentication method in production.\n * @param embedConfig The embed configuration\n */\n\nexport const doBasicAuth = async embedConfig => {\n  const {\n    thoughtSpotHost,\n    username,\n    password\n  } = embedConfig;\n  const loggedIn = await isLoggedIn(thoughtSpotHost);\n\n  if (!loggedIn) {\n    const response = await fetchBasicAuthService(thoughtSpotHost, username, password);\n    loggedInStatus = response.status === 200;\n  }\n\n  loggedInStatus = true;\n};\n\nasync function samlPopupFlow(ssoURL) {\n  document.body.insertAdjacentHTML('beforeend', '<div id=\"ts-saml-auth\"></div>');\n  const authElem = document.getElementById('ts-saml-auth');\n  samlCompletionPromise = samlCompletionPromise || new Promise((resolve, reject) => {\n    window.addEventListener('message', e => {\n      if (e.data.type === EmbedEvent.SAMLComplete) {\n        e.source.close();\n        resolve();\n      }\n    });\n  });\n  authElem.addEventListener('click', () => {\n    if (samlAuthWindow === null || samlAuthWindow.closed) {\n      samlAuthWindow = window.open(ssoURL, '_blank', 'location=no,height=570,width=520,scrollbars=yes,status=yes');\n    } else {\n      samlAuthWindow.focus();\n    }\n  }, {\n    once: true\n  });\n  authElem.click();\n  return samlCompletionPromise;\n}\n/**\n * Perform SAML authentication\n * @param embedConfig The embed configuration\n */\n\n\nconst doSSOAuth = async (embedConfig, ssoEndPoint) => {\n  const {\n    thoughtSpotHost\n  } = embedConfig;\n  const loggedIn = await isLoggedIn(thoughtSpotHost);\n\n  if (loggedIn) {\n    if (isAtSSORedirectUrl()) {\n      removeSSORedirectUrlMarker();\n    }\n\n    loggedInStatus = true;\n    return;\n  } // we have already tried authentication and it did not succeed, restore\n  // the current URL to the original one and invoke the callback.\n\n\n  if (isAtSSORedirectUrl()) {\n    removeSSORedirectUrlMarker();\n    loggedInStatus = false;\n    return;\n  }\n\n  const ssoURL = `${thoughtSpotHost}${ssoEndPoint}`;\n\n  if (embedConfig.noRedirect) {\n    await samlPopupFlow(ssoURL);\n    return;\n  }\n\n  window.location.href = ssoURL;\n};\n\nexport const doSamlAuth = async embedConfig => {\n  const {\n    thoughtSpotHost\n  } = embedConfig; // redirect for SSO, when the SSO authentication is done, this page will be loaded\n  // again and the same JS will execute again.\n\n  const ssoRedirectUrl = embedConfig.noRedirect ? `${thoughtSpotHost}/v2/#/embed/saml-complete` : appendToUrlHash(window.location.href, SSO_REDIRECTION_MARKER_GUID); // bring back the page to the same URL\n\n  const ssoEndPoint = `${EndPoints.SAML_LOGIN_TEMPLATE(encodeURIComponent(ssoRedirectUrl))}`;\n  await doSSOAuth(embedConfig, ssoEndPoint);\n};\nexport const doOIDCAuth = async embedConfig => {\n  const {\n    thoughtSpotHost\n  } = embedConfig; // redirect for SSO, when the SSO authentication is done, this page will be loaded\n  // again and the same JS will execute again.\n\n  const ssoRedirectUrl = embedConfig.noRedirect ? `${thoughtSpotHost}/v2/#/embed/saml-complete` : appendToUrlHash(window.location.href, SSO_REDIRECTION_MARKER_GUID); // bring back the page to the same URL\n\n  const ssoEndPoint = `${EndPoints.OIDC_LOGIN_TEMPLATE(encodeURIComponent(ssoRedirectUrl))}`;\n  await doSSOAuth(embedConfig, ssoEndPoint);\n};\n/**\n * Perform authentication on the ThoughtSpot cluster\n * @param embedConfig The embed configuration\n */\n\nexport const authenticate = async embedConfig => {\n  const {\n    authType\n  } = embedConfig;\n\n  switch (authType) {\n    case AuthType.SSO:\n      return doSamlAuth(embedConfig);\n\n    case AuthType.OIDC:\n      return doOIDCAuth(embedConfig);\n\n    case AuthType.AuthServer:\n      return doTokenAuth(embedConfig);\n\n    case AuthType.Basic:\n      return doBasicAuth(embedConfig);\n\n    default:\n      return Promise.resolve();\n  }\n};\n/**\n * Check if we are authenticated to the ThoughtSpot cluster\n */\n\nexport const isAuthenticated = () => loggedInStatus;","map":{"version":3,"sources":["/Users/quinton.wall/code/thoughtspot-repo/quickstarts/react-starter-app/node_modules/@thoughtspot/visual-embed-sdk/src/auth.ts"],"names":[],"mappings":"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","sourcesContent":["import { initMixpanel } from './mixpanel-service';\nimport { AuthType, EmbedConfig, EmbedEvent } from './types';\nimport { appendToUrlHash } from './utils';\n// eslint-disable-next-line import/no-cycle\nimport {\n    fetchSessionInfoService,\n    fetchAuthTokenService,\n    fetchAuthService,\n    fetchBasicAuthService,\n} from './utils/authService';\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let loggedInStatus = false;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlAuthWindow: Window = null;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlCompletionPromise: Promise<void> = null;\n// eslint-disable-next-line import/no-mutable-exports\nexport let sessionInfo: any = null;\n\nexport const SSO_REDIRECTION_MARKER_GUID =\n    '5e16222e-ef02-43e9-9fbd-24226bf3ce5b';\n\nexport const EndPoints = {\n    AUTH_VERIFICATION: '/callosum/v1/session/info',\n    SAML_LOGIN_TEMPLATE: (targetUrl: string) =>\n        `/callosum/v1/saml/login?targetURLPath=${targetUrl}`,\n    OIDC_LOGIN_TEMPLATE: (targetUrl: string) =>\n        `/callosum/v1/oidc/login?targetURLPath=${targetUrl}`,\n    TOKEN_LOGIN: '/callosum/v1/session/login/token',\n    BASIC_LOGIN: '/callosum/v1/session/login',\n};\n\n/**\n * Check if we are logged into the ThoughtSpot cluster\n * @param thoughtSpotHost The ThoughtSpot cluster hostname or IP\n */\nasync function isLoggedIn(thoughtSpotHost: string): Promise<boolean> {\n    const authVerificationUrl = `${thoughtSpotHost}${EndPoints.AUTH_VERIFICATION}`;\n    let response = null;\n    try {\n        response = await fetchSessionInfoService(authVerificationUrl);\n    } catch (e) {\n        return false;\n    }\n    return response.status === 200;\n}\n\n/**\n * Return sessionInfo if available else make a loggedIn check to fetch the sessionInfo\n */\nexport function getSessionInfo() {\n    return sessionInfo;\n}\n\nexport function initSession(sessionDetails: any) {\n    sessionInfo = sessionDetails;\n    initMixpanel(sessionInfo);\n}\n\n/**\n * Check if we are stuck at the SSO redirect URL\n */\nfunction isAtSSORedirectUrl(): boolean {\n    return window.location.href.indexOf(SSO_REDIRECTION_MARKER_GUID) >= 0;\n}\n\n/**\n * Remove the SSO redirect URL marker\n */\nfunction removeSSORedirectUrlMarker(): void {\n    // Note (sunny): This will leave a # around even if it was not in the URL\n    // to begin with. Trying to remove the hash by changing window.location will reload\n    // the page which we don't want. We'll live with adding an unnecessary hash to the\n    // parent page URL until we find any use case where that creates an issue.\n    window.location.hash = window.location.hash.replace(\n        SSO_REDIRECTION_MARKER_GUID,\n        '',\n    );\n}\n\n/**\n * Perform token based authentication\n * @param embedConfig The embed configuration\n */\nexport const doTokenAuth = async (embedConfig: EmbedConfig): Promise<void> => {\n    const {\n        thoughtSpotHost,\n        username,\n        authEndpoint,\n        getAuthToken,\n    } = embedConfig;\n    if (!authEndpoint && !getAuthToken) {\n        throw new Error(\n            'Either auth endpoint or getAuthToken function must be provided',\n        );\n    }\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (!loggedIn) {\n        let authToken = null;\n        if (getAuthToken) {\n            authToken = await getAuthToken();\n        } else {\n            const response = await fetchAuthTokenService(authEndpoint);\n            authToken = response.text();\n        }\n        await fetchAuthService(thoughtSpotHost, username, authToken);\n        loggedInStatus = false;\n    }\n\n    loggedInStatus = true;\n};\n\n/**\n * Perform basic authentication to the ThoughtSpot cluster using the cluster\n * credentials.\n *\n * Warning: This feature is primarily intended for developer testing. It is\n * strongly advised not to use this authentication method in production.\n * @param embedConfig The embed configuration\n */\nexport const doBasicAuth = async (embedConfig: EmbedConfig): Promise<void> => {\n    const { thoughtSpotHost, username, password } = embedConfig;\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (!loggedIn) {\n        const response = await fetchBasicAuthService(\n            thoughtSpotHost,\n            username,\n            password,\n        );\n        loggedInStatus = response.status === 200;\n    }\n\n    loggedInStatus = true;\n};\n\nasync function samlPopupFlow(ssoURL: string) {\n    document.body.insertAdjacentHTML(\n        'beforeend',\n        '<div id=\"ts-saml-auth\"></div>',\n    );\n    const authElem = document.getElementById('ts-saml-auth');\n    samlCompletionPromise =\n        samlCompletionPromise ||\n        new Promise<void>((resolve, reject) => {\n            window.addEventListener('message', (e) => {\n                if (e.data.type === EmbedEvent.SAMLComplete) {\n                    (e.source as Window).close();\n                    resolve();\n                }\n            });\n        });\n    authElem.addEventListener(\n        'click',\n        () => {\n            if (samlAuthWindow === null || samlAuthWindow.closed) {\n                samlAuthWindow = window.open(\n                    ssoURL,\n                    '_blank',\n                    'location=no,height=570,width=520,scrollbars=yes,status=yes',\n                );\n            } else {\n                samlAuthWindow.focus();\n            }\n        },\n        { once: true },\n    );\n    authElem.click();\n    return samlCompletionPromise;\n}\n\n/**\n * Perform SAML authentication\n * @param embedConfig The embed configuration\n */\nconst doSSOAuth = async (\n    embedConfig: EmbedConfig,\n    ssoEndPoint: string,\n): Promise<void> => {\n    const { thoughtSpotHost } = embedConfig;\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (loggedIn) {\n        if (isAtSSORedirectUrl()) {\n            removeSSORedirectUrlMarker();\n        }\n        loggedInStatus = true;\n        return;\n    }\n\n    // we have already tried authentication and it did not succeed, restore\n    // the current URL to the original one and invoke the callback.\n    if (isAtSSORedirectUrl()) {\n        removeSSORedirectUrlMarker();\n        loggedInStatus = false;\n        return;\n    }\n\n    const ssoURL = `${thoughtSpotHost}${ssoEndPoint}`;\n    if (embedConfig.noRedirect) {\n        await samlPopupFlow(ssoURL);\n        return;\n    }\n\n    window.location.href = ssoURL;\n};\n\nexport const doSamlAuth = async (embedConfig: EmbedConfig) => {\n    const { thoughtSpotHost } = embedConfig;\n    // redirect for SSO, when the SSO authentication is done, this page will be loaded\n    // again and the same JS will execute again.\n    const ssoRedirectUrl = embedConfig.noRedirect\n        ? `${thoughtSpotHost}/v2/#/embed/saml-complete`\n        : appendToUrlHash(window.location.href, SSO_REDIRECTION_MARKER_GUID);\n\n    // bring back the page to the same URL\n    const ssoEndPoint = `${EndPoints.SAML_LOGIN_TEMPLATE(\n        encodeURIComponent(ssoRedirectUrl),\n    )}`;\n\n    await doSSOAuth(embedConfig, ssoEndPoint);\n};\n\nexport const doOIDCAuth = async (embedConfig: EmbedConfig) => {\n    const { thoughtSpotHost } = embedConfig;\n    // redirect for SSO, when the SSO authentication is done, this page will be loaded\n    // again and the same JS will execute again.\n    const ssoRedirectUrl = embedConfig.noRedirect\n        ? `${thoughtSpotHost}/v2/#/embed/saml-complete`\n        : appendToUrlHash(window.location.href, SSO_REDIRECTION_MARKER_GUID);\n\n    // bring back the page to the same URL\n    const ssoEndPoint = `${EndPoints.OIDC_LOGIN_TEMPLATE(\n        encodeURIComponent(ssoRedirectUrl),\n    )}`;\n\n    await doSSOAuth(embedConfig, ssoEndPoint);\n};\n\n/**\n * Perform authentication on the ThoughtSpot cluster\n * @param embedConfig The embed configuration\n */\nexport const authenticate = async (embedConfig: EmbedConfig): Promise<void> => {\n    const { authType } = embedConfig;\n    switch (authType) {\n        case AuthType.SSO:\n            return doSamlAuth(embedConfig);\n        case AuthType.OIDC:\n            return doOIDCAuth(embedConfig);\n        case AuthType.AuthServer:\n            return doTokenAuth(embedConfig);\n        case AuthType.Basic:\n            return doBasicAuth(embedConfig);\n        default:\n            return Promise.resolve();\n    }\n};\n\n/**\n * Check if we are authenticated to the ThoughtSpot cluster\n */\nexport const isAuthenticated = (): boolean => loggedInStatus;\n"]},"metadata":{},"sourceType":"module"}